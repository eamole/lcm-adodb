// Generated by CoffeeScript 2.3.1
(function() {
  var ADODB, Db, Field, JsonCache, Table, adodb;

  ADODB = require('node-adodb');

  JsonCache = require("./utils");

  // ADO constants
  adodb = {
    schemaEnum: {
      columns: 4,
      indexes: 12,
      procedures: 16,
      tables: 20,
      providerTypes: 22,
      views: 23,
      foreignKeys: 27,
      primaryKeys: 28,
      members: 38
    },
    typeEnum: {
      empty: 0,
      smallInt: 2,
      integer: 3, // default number/autonumber 10 places
      single: 4,
      double: 5,
      currency: 6,
      date: 7,
      bstr: 8,
      idispatch: 9,
      error: 10,
      boolean: 11,
      variant: 12,
      iunknown: 13,
      decimal: 14,
      tinyInt: 15,
      unsignedTinyInt: 16,
      wchar: 130 // unicode string
    }
  };

  Db = class Db {
    constructor(name1, path, password, ext = ".mdb") {
      // actually already have the data below!! but should really allow the cache to play with it before using it
      this.adodbTablesReceived = this.adodbTablesReceived.bind(this);
      this.adodbGetTables = this.adodbGetTables.bind(this);
      // kludge - should return a promise!! - instead using a callback!! needs to be bound
      this.getTables = this.getTables.bind(this);
      this.getFields = this.getFields.bind(this);
      this.adodbFieldsReceived = this.adodbFieldsReceived.bind(this);
      this.adodbGetFields = this.adodbGetFields.bind(this);
      this.name = name1;
      this.path = path;
      this.password = password;
      this.ext = ext;
      this.passString = "";
      if (this.password != null) {
        this.passString = `Jet OLEDB:Database Password=${this.password}`;
      }
      this.file = this.path + this.ext;
      this.provider = 'Provider=Microsoft.ACE.OLEDB.12.0';
      this.dataSource = `Data Source=${this.file}`;
      this.connected = false;
      this.cacheTables = new JsonCache(`storage/db/${this.name}/`, "adodb-table-list", this.adodbGetTables, this.adodbTablesReceived);
      this.cacheFields = new JsonCache(`storage/db/${this.name}/`, "tables", this.adodbGetFields, this.adodbFieldsReceived);
    }

    connect() {
      var cnnString;
      cnnString = `${this.provider};${this.dataSource};${this.passString}`;
      this.cnn = ADODB.open(cnnString);
      return this.connected = true;
    }

    getTable(name) {
      var table;
      if (this.tables[name] == null) {
        console.log(`table [${name} not found in database.tables`);
      }
      return table = this.tables[name];
    }

    adodbTablesReceived(tableList1) { // @ in promise/cb
      var i, len, ref, results, table, tablename;
      this.tableList = tableList1;
      // this is not indexed!
      //    @tables = @tableList.map (tableName) => # @ inside cb
      //      new Table(@,tableName)
      this.tables = {};
      ref = this.tableList;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tablename = ref[i];
        table = new Table(this, tablename);
        results.push(this.tables[tablename] = table);
      }
      return results;
    }

    adodbGetTables(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.cnn.schema(20).then((schema) => { // fat for @ in promise
        this.schema = schema;
        this.tableList = this.schema.map(function(adoRec) {
          return adoRec['TABLE_NAME'];
        });
        // @adodbTablesReceived @tableList // cyclic will be called below - why specify separately???
        // will be called after cache has been saved
        return cb(this.tableList); // cache.onRefresh + showAll!!
      }).catch(function(e) {
        return console.log(`adodbGetTables Error : ${e} `);
      });
    }

    getTables(cb) { //showAll     # fat - used as a static callback
      //# use the cache
      if (this.tables) {
        return cb(this.tables);
      } else {
        return this.cacheTables.getData(cb); //showAll
      }
    }

    getFields(cb) { //showAll     # fat - used as a static callback
      //# use the cache
      if (this.fields) {
        return cb(this.fields);
      } else {
        return this.cacheFields.getData(cb); //showAll
      }
    }

    adodbFieldsReceived(tables) { // @ in promise/cb - should really use the rawFieldlist here
      this.tables = tables;
      return console.log("why here");
    }

    adodbGetFields(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.cnn.schema(4).then((schema) => { // , [null,null,null]   # get ALL fields in db // fat for @ in promise
        var ado, i, len, ref, table, tableList, tableName;
        this.schema = schema;
        tableList = this.schema.map(function(ado) {
          return ado['TABLE_NAME'];
        });
        this.tableList = [...new Set(tableList)]; // unique tables as list
        ref = this.schema;
        // construct the @tables
        for (i = 0, len = ref.length; i < len; i++) {
          ado = ref[i];
          tableName = ado['TABLE_NAME'];
          if (this.tables == null) {
            // check if already exists
            this.tables = {};
          }
          if (this.tables[tableName] == null) {
            table = this.addTable(tableName);
          }
          table = this.tables[tableName];
          table.addField(ado);
        }
        return cb(this.tables); // cache.onRefresh + showAll!!
      }).catch(function(e) {
        return console.log(`adodbGetFields Error : ${e} `);
      });
    }

    // single query retuirns all fields, which give you all tables as well
    xgetFields(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.db.cnn.schema(4, [null, null, null]).then((schema) => { // fat for @ in promise
        var fieldObj, i, len, ref, results, table, tableName;
        this.schema = schema;
        ref = this.schema;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          fieldObj = ref[i];
          tableName = tableObj['TABLE_NAME'];
          if (this.tables[tableName] == null) {
            // check if already exists
            table = this.addTable(this, tableName);
          }
          table = this.tables[tableName];
          results.push(table.addField(fieldObj));
        }
        return results;
      }).then(function() {
        return cb();
      }).catch(function(e) {
        return console.log(`getFields Error : ${e} `);
      });
    }

    addTable(name) {
      var table;
      table = new Table(this, name);
      this.tables[name] = table;
      return table;
    }

  };

  Table = class Table {
    constructor(db, name1) {
      this.toJSON = this.toJSON.bind(this);
      this.db = db;
      this.name = name1;
      this.fields = {};
    }

    dump() {
      return console.log(`Hello from table ${this.name}`);
    }

    getFields() {
      return this.db.cnn.schema(4, [null, null, this.name]).then((schema) => { // fat for @ in promise
        var column, i, len, ref, results;
        this.schema = schema;
        ref = this.schema;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          column = ref[i];
          results.push(this.addField(column));
        }
        return results;
      }).catch(function(e) {
        return console.log(`getFields Error : ${e}`);
      });
    }

    addField(column) {
      var field;
      field = new Field(this, column);
      this.fields[field.name] = field;
      return field;
    }

    toJSON(key) { // fat @
      if (key != null) {
        return {
          name: this.name,
          fields: this.fields
        };
      } else {
        return this;
      }
    }

  };

  Field = (function() {
    class Field {
      constructor(table1, ado1) {
        var e;
        this.toJSON = this.toJSON.bind(this);
        this.table = table1;
        this.ado = ado1;
        try {
          this.name = this.ado['COLUMN_NAME'];
          this.itype = this.ado['DATA_TYPE'];
          this.type = Field.types[this.itype];
          this.ord = this.ado['ORDINAL_POSITION'];
          this.size = this.ado['CHARACTER_MAXIMUM_LENGTH'] || this.ado['NUMERIC_PRECISION'];
          this.nullable = this.ado['IS_NULLABLE'];
          this.hasDefault = this.ado['COLUMN_HAS_DEFAULT'];
          this.default = this.ado['COLUMN_DEFAULT'];
        } catch (error) {
          e = error;
          console.log(`Field Error : ${e}`);
        }
      }

      // static
      static getTypes() {
        var key, ref, results, value;
        ref = adodb.typeEnum;
        // invert the enums above
        results = [];
        for (value in ref) {
          key = ref[value];
          results.push(this.types[key] = value);
        }
        return results;
      }

      toJSON(key) {
        return {
          // need to remove backpointer table!!
          name: this.name,
          itype: this.itype,
          type: this.type,
          ord: this.ord,
          size: this.size,
          nullable: this.nullable,
          hasDefault: this.hasDefault,
          default: this.default
        };
      }

    };

    Field.types = {};

    return Field;

  }).call(this);

  //    o={}
  //    for v,k of @
  //      o[k] = v if k not in ["table","ado"]
  //    o
  // static call
  Field.getTypes();

  module.exports = Db;

}).call(this);

//# sourceMappingURL=db.js.map
