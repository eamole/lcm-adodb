// Generated by CoffeeScript 2.3.1
(function() {
  var ADODB, Db, Field, JsonCache, Table, adodb, fs, pathExists, promise, table_id, writeFile;

  ADODB = require('./adodb'); // require('node-adodb');

  ({JsonCache, pathExists, writeFile} = require("./utils"));

  fs = require('fs-extra');

  //Provider=Microsoft.ACE.OLEDB.12.0;Data Source=E:\ResMgr\amdex\resmanager;Jet OLEDB:Database Password=AERLINGUS
  table_id = 0;

  promise = function(fn) {
    return new Promise(function(resolve, reject) {
      var e;
      try {
        return resolve(fn());
      } catch (error) {
        e = error;
        return reject(e);
      }
    });
  };

  // ADO constants
  adodb = {
    schemaEnum: {
      columns: 4,
      indexes: 12,
      procedures: 16,
      tables: 20,
      providerTypes: 22,
      views: 23,
      foreignKeys: 27,
      primaryKeys: 28,
      members: 38
    },
    typeEnum: {
      empty: 0,
      smallInt: 2,
      integer: 3, // default number/autonumber 10 places
      single: 4,
      double: 5,
      currency: 6,
      date: 7,
      bstr: 8,
      idispatch: 9,
      error: 10,
      boolean: 11,
      variant: 12,
      iunknown: 13,
      decimal: 14,
      tinyInt: 15,
      unsignedTinyInt: 16,
      wchar: 130 // unicode string
    }
  };

  Db = class Db {
    constructor(name1, path, password, ext = ".mdb") {
      // actually already have the data below!! but should really allow the cache to play with it before using it
      this.adodbTablesReceived = this.adodbTablesReceived.bind(this);
      this.adodbGetTables = this.adodbGetTables.bind(this);
      // kludge - should return a promise!! - instead using a callback!! needs to be bound
      this.getTables = this.getTables.bind(this);
      
      // should rewrite this using promises
      this.getFields = this.getFields.bind(this);
      this.adodbFieldsReceived = this.adodbFieldsReceived.bind(this);
      this.adodbGetFields = this.adodbGetFields.bind(this);
      this.name = name1;
      this.path = path;
      this.password = password;
      this.ext = ext;
      this.storagePath = `storage/db/${this.name}/`;
      pathExists(this.storagePath);
      this.passString = "";
      if (this.password != null) {
        this.passString = `Jet OLEDB:Database Password=${this.password}`;
      }
      this.file = this.path + this.ext;
      this.provider = 'Provider=Microsoft.ACE.OLEDB.12.0';
      this.dataSource = `Data Source=${this.file}`;
      this.connected = false;
      this.cacheTables = new JsonCache(this.storagePath, "adodb-table-list", this.adodbGetTables, this.adodbTablesReceived);
      this.cacheFields = new JsonCache(this.storagePath, "tables", this.adodbGetFields, this.adodbFieldsReceived);
      this.tables = {};
    }

    connect() {
      var cnnString;
      cnnString = `${this.provider};${this.dataSource};${this.passString}`;
      this.cnn = ADODB.open(cnnString);
      return this.connected = true;
    }

    query(sql) {
      var data;
      if (!this.connected) {
        this.connect();
      }
      data = this.cnn.query(sql);
      return data;
    }

    getTable(name) {
      var table;
      if (this.tables[name] == null) {
        console.log(`table [${name} not found in database.tables`);
      }
      return table = this.tables[name];
    }

    adodbTablesReceived(tableList1) { // @ in promise/cb
      var i, len, ref, results, table, tablename;
      this.tableList = tableList1;
      // this is not indexed!
      //    @tables = @tableList.map (tableName) => # @ inside cb
      //      new Table(@,tableName)
      this.tables = {};
      ref = this.tableList;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        tablename = ref[i];
        table = new Table(this, tablename);
        results.push(this.tables[tablename] = table);
      }
      return results;
    }

    adodbGetTables(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.cnn.schema(20).then((schema) => { // fat for @ in promise
        this.schema = schema;
        this.tableList = this.schema.map(function(adoRec) {
          return adoRec['TABLE_NAME'];
        });
        // @adodbTablesReceived @tableList // cyclic will be called below - why specify separately???
        // will be called after cache has been saved
        return cb(this.tableList); // cache.onRefresh + showAll!!
      }).catch(function(e) {
        return console.log(`adodbGetTables Error : ${e} `);
      });
    }

    getTables(cb) { //showAll     # fat - used as a static callback
      //# use the cache
      if (this.tables) {
        return cb(this.tables);
      } else {
        return this.cacheTables.getData(cb); //showAll
      }
    }

    getFields() { //showAll     # fat - used as a static callback
      // use the cache
      if (this.fields) {
        return Promise.resolve(this.fields);
      } else {
        return this.cacheFields.getData(); //showAll
      }
    }

    adodbFieldsReceived(tables) { // @ in promise/cb - should really use the rawFieldlist here
      var k, results, v;
      console.log("convert json data to table/field objects");
// its an object not array
// this called after the cache has been read AND after the data has been received from adodb
// process the json data
      results = [];
      for (k in tables) {
        v = tables[k];
        results.push(Table.fromJson(this, v));
      }
      return results;
    }

    adodbGetFields(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.cnn.schema(4).then((schema) => { // , [null,null,null]   # get ALL fields in db // fat for @ in promise
        var ado, i, len, ref, table, tableList, tableName;
        this.schema = schema;
        tableList = this.schema.map(function(ado) {
          return ado['TABLE_NAME'];
        });
        this.tableList = [...new Set(tableList)]; // unique tables as list
        ref = this.schema;
        // construct the @tables
        for (i = 0, len = ref.length; i < len; i++) {
          ado = ref[i];
          tableName = ado['TABLE_NAME'];
          if (this.tables == null) {
            // check if already exists
            this.tables = {};
          }
          if (this.tables[tableName] == null) {
            table = this.addTable(tableName);
          }
          table = this.tables[tableName];
          table.addField(ado);
        }
        return cb(this.tables); // cache.onRefresh + showAll!!
      }).catch(function(e) {
        return console.log(`adodbGetFields Error : ${e} `);
      });
    }

    // single query retuirns all fields, which give you all tables as well
    xgetFields(cb) {
      if (!this.connected) {
        this.connect();
      }
      return this.cnn.schema(4, [null, null, null]).then((schema) => { // fat for @ in promise
        var fieldObj, i, len, ref, results, table, tableName;
        this.schema = schema;
        ref = this.schema;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          fieldObj = ref[i];
          tableName = tableObj['TABLE_NAME'];
          if (this.tables[tableName] == null) {
            // check if already exists
            table = this.addTable(this, tableName);
          }
          table = this.tables[tableName];
          results.push(table.addField(fieldObj));
        }
        return results;
      }).then(function() {
        return cb();
      }).catch(function(e) {
        return console.log(`getFields Error : ${e} `);
      });
    }

    addTable(name) {
      var table;
      table = new Table(this, name);
      //    @tables[name] = table
      return table;
    }

  };

  Table = (function() {
    class Table {
      constructor(db1, name1) {
        var fields;
        this.toJSON = this.toJSON.bind(this);
        this.db = db1;
        this.name = name1;
        if (!this.id) {
          this.id = ++table_id;
        }
        if (!this.primaryKey) {
          this.primaryKey = "";
        }
        this.fields = {};
        this.db.tables[this.name] = this;
        this.count = 0;
        this.storagePath = this.db.storagePath + `${this.name}/`;
        pathExists(this.storagePath);
        fields = []; // temp holder ousteide scope
        fs.exists(this.storagePath + Table.filenameMetadata, (exists) => {
          if (exists) {
            return this.unpersistMetadata();
          }
        });
      }

      // only needed if metadata changes
      //          .then =>
      //            fields = Object.values(@fields)
      //            fields.sort (a,b) ->
      //              a.ord - b.ord
      //          .then =>
      //            #convert array back to object
      //            @fields = {}  # reset
      //            for field in fields
      //              @fields[field.name]=field
      //          .then =>
      //            @persistMetadata()
      meta() {
        var field, fields, i, len;
        //only needed if metadata changes
        fields = Object.values(this.fields);
        fields.sort(function(a, b) {
          return a.ord - b.ord;
        });
        //convert array back to object
        this.fields = {}; // reset
        for (i = 0, len = fields.length; i < len; i++) {
          field = fields[i];
          this.fields[field.name] = field;
        }
        return this.persistMetadata();
      }

      // this is largely redundant
      static fromJson(db, tableJson) {
        var fieldJson, k, ref, results, table;
        console.log("Dint forget to get rid of static Table.fromJson being used to load from fields file ");
        table = db.addTable(tableJson.name);
        ref = tableJson.fields;
        // obj not array
        //    table.count = tableJson.count if tableJson.count?
        results = [];
        for (k in ref) {
          fieldJson = ref[k];
          results.push(Field.fromJson(table, fieldJson));
        }
        return results;
      }

      // restore this object
      _fromJson(json) {
        if (json.id != null) {
          this.id = json.id;
        }
        this.name = json.name;
        if (json.primaryKey != null) {
          this.primaryKey = json.primaryKey;
        }
        this.count = json.count;
        return this.fields = json.fields;
      }

      toJSON(key) { // fat @
        if (key != null) {
          return {
            id: this.id,
            name: this.name,
            primaryKey: this.primaryKey,
            count: this.count,
            fields: this.fields
          };
        } else {
          return this;
        }
      }

      dump() {
        return console.log(`Hello from table ${this.name}`);
      }

      // lets try code this with a promise!! - adodb returns promise
      adodbGetCount() {
        return this.db.query(`SELECT count(*) as count FROM ${this.name};`).then((data) => {
          // adodb returns funny structure for expressions such as count
          this.count = data[0].Expr1000; // its an array with 1 value
          return console.log(`Record count ${this.name} : ${this.count}`);
        }).catch((err) => {
          return console.log("Table.getCount()", err);
        });
      }

      // reads data into cache
      adodbGetData() {
        return this.db.query(`SELECT * FROM ${this.name};`).then((data1) => {
          this.data = data1;
        //        @data = []  # this will probably be a keyed object, once I've set the keys
        //        for k,row in data
        //          @data.push data
        }).then(() => { // fat @
          this.count = this.data.length;
          return this.persistMetadata();
        }).then(() => { // fat @
          return this.persistData();
        });
      }

      adodbGetFields() {
        return this.db.cnn.schema(4, [null, null, this.name]).then((schema) => { // fat for @ in promise
          var column, i, len, ref, results;
          this.schema = schema;
          ref = this.schema;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            column = ref[i];
            results.push(this.addField(column));
          }
          return results;
        }).catch(function(e) {
          return console.log(`getFields Error : ${e}`);
        });
      }

      addAdodbField(ado) {
        var field;
        field = Field.fromAdodb(this, ado);
        //    @fields[field.name]=field
        return field;
      }

      unpersistMetadata() {
        var filename;
        filename = this.storagePath + Table.filenameMetadata;
        return fs.exists(filename).then((exists) => {
          return fs.readFile(filename).then((data) => {
            var json;
            json = JSON.parse(data);
            return this._fromJson(json);
          });
        });
      }

      unpersistData() {
        var filename;
        filename = this.storagePath + Table.filenameData;
        return fs.exists(filename).then((exists) => {
          return fs.readFile(filename).then((data) => {
            return this.data = JSON.parse(data);
          });
        });
      }

      // saves the table meta data
      persistData() {
        var data;
        data = JSON.stringify(this.data, null, 2);
        return writeFile(this.storagePath, Table.filenameData, data);
      }

      // save meta
      persistMetadata() {
        var data;
        data = JSON.stringify(this, null, 2);
        return promise(() => {
          return writeFile(this.storagePath, Table.filenameMetadata, data);
        });
      }

      getData() {
        var filename;
        if (this.data) {
          return Promise.resolve(this.data);
        } else {
          filename = this.storagePath + Table.filenameData;
          return fs.exists(filename).then((exists) => {
            if (exists) {
              return this.unpersistData();
            } else {
              return this.adodbGetData();
            }
          });
        }
      }

    };

    //statics
    Table.filenameData = "data.json";

    Table.filenameMetadata = "metadata.json";

    return Table;

  }).call(this);

  Field = (function() {
    class Field {
      constructor(table1, name1) {
        this.toJSON = this.toJSON.bind(this);
        this.table = table1;
        this.name = name1;
        this.table.fields[this.name] = this;
      }

      // static
      static fromAdodb(table, ado) {
        var e, f, name;
        try {
          name = this.ado['COLUMN_NAME'];
          f = new Field(table, name);
          f.itype = ado['DATA_TYPE'];
          f.type = Field.types[f.itype];
          f.ord = ado['ORDINAL_POSITION'];
          f.size = ado['CHARACTER_MAXIMUM_LENGTH'] || ado['NUMERIC_PRECISION'];
          f.nullable = ado['IS_NULLABLE'];
          f.hasDefault = ado['COLUMN_HAS_DEFAULT'];
          f.default = ado['COLUMN_DEFAULT'];
        } catch (error) {
          e = error;
          console.log(`Field Error : ${e}`);
        }
        return f; // return
      }

      static fromJson(table, fieldJson) {
        var f;
        f = new Field(table, fieldJson.name);
        // i don't think any special processing is required
        f = Object.assign(f, fieldJson);
        //    table.fields[fieldJson.name] = f
        return f;
      }

      static getTypes() {
        var key, ref, results, value;
        ref = adodb.typeEnum;
        // invert the enums above
        results = [];
        for (value in ref) {
          key = ref[value];
          results.push(this.types[key] = value);
        }
        return results;
      }

      toJSON(key) {
        return {
          // need to remove backpointer table!!
          name: this.name,
          itype: this.itype,
          type: this.type,
          ord: this.ord,
          size: this.size,
          nullable: this.nullable,
          hasDefault: this.hasDefault,
          default: this.default
        };
      }

    };

    Field.types = {};

    return Field;

  }).call(this);

  //    o={}
  //    for v,k of @
  //      o[k] = v if k not in ["table","ado"]
  //    o
  // static call
  Field.getTypes();

  module.exports = Db;

}).call(this);

//# sourceMappingURL=db.js.map
